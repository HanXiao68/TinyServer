## 项目的思考
####     为什么使用Reactor模型而不是Proactor模型？
   * Reactor是同步非阻塞模型；Proactor是异步非阻塞模型。两者的区别是在于：IO具体是由产生IO的主线程完成，还是交给操作系统来完成。
   * 异步IO需要操作系统支持，如windows下的IOCP属于异步IO，Boost.ASIO.。因为当前Linux下AIO还不够成熟，本项目在Ubuntu下开发测试。所以，本项目使用的reactor模型。
   * Reactor模型网络库：libevent, libev, libuv。

## 为什么使用长连接，长连接是怎么实现的？
* 长连接指在一个TCP连接上可以发送多个HTTP请求和响应，可以避免重复建立TCP连接导致效率低下。
* 实现长连接需要以下两步：
        * 将IO设置为non-blocking I/O,此时read有数据则读取并返回读取的字节数，没数据则返回 -1并设置errno为EAGAIN，表示下次有数据时在读取。目的是防止长连接下数据未读取完 一直被阻塞，（长连接下服务器端read不知道下一次请求在什么时候到来）
        * 设置epoll为ET模式（边缘触发模式），只有状态发生变化时，才会被epoll_wait返回，其他时候不返回。所以在长连接情况下不会因为数据未读完而每次都返回。ET 可以提高系统效率，避免每次检查没有数据的描述符。
